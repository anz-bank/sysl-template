// Code generated by sysl DO NOT EDIT.
package flickr

import (
	"context"
	"fmt"
	"net/http"
	"net/url"

	"github.com/anz-bank/sysl-go/common"
	"github.com/anz-bank/sysl-go/restlib"
	"github.com/anz-bank/sysl-go/validator"
)

// Service interface for Flickr
type Service interface {
	GetRestList(ctx context.Context, req *GetRestListRequest) (*PhotoResource, error)
}

// Client for Flickr API
type Client struct {
	client *http.Client
	url    string
}

// NewClient for Flickr
func NewClient(client *http.Client, serviceURL string) *Client {
	return &Client{client, serviceURL}
}

// GetRestList ...
func (s *Client) GetRestList(ctx context.Context, req *GetRestListRequest) (*PhotoResource, error) {
	required := []string{}
	var okResponse PhotoResource
	u, err := url.Parse(fmt.Sprintf("%s/rest", s.url))
	if err != nil {
		return nil, common.CreateError(ctx, common.InternalError, "failed to parse url", err)
	}

	q := u.Query()
	if req.Method != nil {
		q.Add("method", *req.Method)
	}

	if req.Text != nil {
		q.Add("text", *req.Text)
	}

	if req.Tags != nil {
		q.Add("tags", *req.Tags)
	}

	if req.User_id != nil {
		q.Add("user_id", *req.User_id)
	}

	if req.Min_upload_date != nil {
		q.Add("min_upload_date", *req.Min_upload_date)
	}

	if req.Max_upload_date != nil {
		q.Add("max_upload_date", *req.Max_upload_date)
	}

	if req.Min_taken_date != nil {
		q.Add("min_taken_date", *req.Min_taken_date)
	}

	if req.Max_taken_date != nil {
		q.Add("max_taken_date", *req.Max_taken_date)
	}

	if req.License != nil {
		q.Add("license", *req.License)
	}

	if req.Sort != nil {
		q.Add("sort", *req.Sort)
	}

	if req.Bbox != nil {
		q.Add("bbox", *req.Bbox)
	}

	if req.Accuracy != nil {
		q.Add("accuracy", *req.Accuracy)
	}

	if req.Machine_tags != nil {
		q.Add("machine_tags", *req.Machine_tags)
	}

	if req.Machine_tag_mode != nil {
		q.Add("machine_tag_mode", *req.Machine_tag_mode)
	}

	if req.Group_id != nil {
		q.Add("group_id", *req.Group_id)
	}

	if req.Contacts != nil {
		q.Add("contacts", *req.Contacts)
	}

	if req.Woe_id != nil {
		q.Add("woe_id", *req.Woe_id)
	}

	if req.Place_id != nil {
		q.Add("place_id", *req.Place_id)
	}

	if req.Media != nil {
		q.Add("media", *req.Media)
	}

	if req.Has_geo != nil {
		q.Add("has_geo", *req.Has_geo)
	}

	if req.Geo_context != nil {
		q.Add("geo_context", *req.Geo_context)
	}

	if req.Lat != nil {
		q.Add("lat", *req.Lat)
	}

	if req.Lon != nil {
		q.Add("lon", *req.Lon)
	}

	if req.Radius_units != nil {
		q.Add("radius_units", *req.Radius_units)
	}

	if req.Is_commons != nil {
		q.Add("is_commons", fmt.Sprintf("%v", *req.Is_commons))
	}

	if req.In_gallery != nil {
		q.Add("in_gallery", fmt.Sprintf("%v", *req.In_gallery))
	}

	if req.Is_getty != nil {
		q.Add("is_getty", fmt.Sprintf("%v", *req.Is_getty))
	}

	u.RawQuery = q.Encode()
	result, err := restlib.DoHTTPRequest(ctx, s.client, "GET", u.String(), nil, required, &okResponse, nil)
	if err != nil {
		return nil, common.CreateError(ctx, common.DownstreamUnavailableError, "call failed: Flickr <- GET "+u.String(), err)
	}

	if result.HTTPResponse.StatusCode == http.StatusUnauthorized {
		return nil, common.CreateDownstreamError(ctx, common.DownstreamUnauthorizedError, result.HTTPResponse, result.Body, nil)
	}
	OkPhotoResourceResponse, ok := result.Response.(*PhotoResource)
	if ok {
		valErr := validator.Validate(OkPhotoResourceResponse)
		if valErr != nil {
			return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, valErr)
		}

		return OkPhotoResourceResponse, nil
	}

	return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, nil)
}
